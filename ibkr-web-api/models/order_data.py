# coding: utf-8

"""
    Client Portal Web API

    Client Poral Web API

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from ibkr-web-api.models.order_data_warnings import OrderDataWarnings
from typing import Optional, Set
from typing_extensions import Self

class OrderData(BaseModel):
    """
    OrderData
    """ # noqa: E501
    client_order_id: Optional[StrictStr] = Field(default=None, alias="clientOrderId")
    exec_id: Optional[StrictStr] = Field(default=None, alias="execId")
    exec_type: Optional[StrictStr] = Field(default=None, alias="execType")
    order_type: Optional[StrictStr] = Field(default=None, alias="orderType")
    order_status: Optional[StrictStr] = Field(default=None, alias="orderStatus")
    symbol: Optional[StrictStr] = Field(default=None, description="Underlying symbol for contract")
    order_qty: Optional[StrictStr] = Field(default=None, description="Quantity of active order", alias="orderQty")
    price: Optional[StrictStr] = Field(default=None, description="Price of active order")
    last_shares: Optional[StrictStr] = Field(default=None, description="Quantity of the last partial fill", alias="lastShares")
    last_price: Optional[StrictStr] = Field(default=None, description="Price of the last partial fill", alias="lastPrice")
    cum_qty: Optional[StrictStr] = Field(default=None, description="Cumulative fill quantity", alias="cumQty")
    leaves_qty: Optional[StrictStr] = Field(default=None, description="Remaining quantity to be filled", alias="leavesQty")
    avg_price: Optional[StrictStr] = Field(default=None, description="Average fill price", alias="avgPrice")
    side: Optional[StrictStr] = None
    order_id: Optional[StrictStr] = Field(default=None, description="Order identifier", alias="orderId")
    account: Optional[StrictStr] = Field(default=None, description="Account number")
    sec_type: Optional[StrictStr] = Field(default=None, description="Contracts asset class", alias="secType")
    tx_time: Optional[StrictStr] = Field(default=None, description="Time of transaction in GMT, format YYYYMMDD-hh:m:ss", alias="txTime")
    rcpt_time: Optional[StrictStr] = Field(default=None, description="Time of receipt in GMT, format YYYYMMDD-hh:mm:ss", alias="rcptTime")
    tif: Optional[StrictStr] = Field(default=None, description="Time in Force")
    conid: Optional[StrictStr] = Field(default=None, description="Contract identifier from IBKR's database.")
    currency: Optional[StrictStr] = Field(default=None, description="Trading currency")
    exchange: Optional[StrictStr] = Field(default=None, description="Exchange or venue")
    listing_exchange: Optional[StrictStr] = Field(default=None, description="Listing Exchange", alias="listingExchange")
    text: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="error message")
    warnings: Optional[OrderDataWarnings] = None
    comm_curr: Optional[StrictStr] = Field(default=None, description="Commission currency", alias="commCurr")
    comms: Optional[StrictStr] = Field(default=None, description="Commissions")
    realized_pnl: Optional[StrictStr] = Field(default=None, description="Realized PnL", alias="realizedPnl")
    __properties: ClassVar[List[str]] = ["clientOrderId", "execId", "execType", "orderType", "orderStatus", "symbol", "orderQty", "price", "lastShares", "lastPrice", "cumQty", "leavesQty", "avgPrice", "side", "orderId", "account", "secType", "txTime", "rcptTime", "tif", "conid", "currency", "exchange", "listingExchange", "text", "warnings", "commCurr", "comms", "realizedPnl"]

    @field_validator('exec_type')
    def exec_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['-1 \"Invalid\"', '0 \"New\"', '1 \"Partially Filled\"', '2 \"Filled\"', '3 \"Done for the Day\"', '4 \"Canceled\"', '5 \"Replaced\"', '6 \"Pending Cancel\"', '7 \"Stopped\"', '8 \"Rejected\"', '9 \"Suspended\"', 'A \"Pending New\"', 'B \"Calculated\"', 'C \"Expired\"', 'D \"Restated\"', 'E \"Pending Replace\"', 'F \"Trade\"', 'G \"Trade Correct\"', 'H \"Trade Cancel\"', 'I \"Order Status\"']):
            raise ValueError("must be one of enum values ('-1 \"Invalid\"', '0 \"New\"', '1 \"Partially Filled\"', '2 \"Filled\"', '3 \"Done for the Day\"', '4 \"Canceled\"', '5 \"Replaced\"', '6 \"Pending Cancel\"', '7 \"Stopped\"', '8 \"Rejected\"', '9 \"Suspended\"', 'A \"Pending New\"', 'B \"Calculated\"', 'C \"Expired\"', 'D \"Restated\"', 'E \"Pending Replace\"', 'F \"Trade\"', 'G \"Trade Correct\"', 'H \"Trade Cancel\"', 'I \"Order Status\"')")
        return value

    @field_validator('order_type')
    def order_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['1 \"Market\"', '2 \"Limit\"', '3 \"Stop\"', '4 \"Stop Limit\"', '5 \"Market on Close\"', '6 \"With or Without\"', '7 \"Limit or Better\"', '8 \"Limit With or Without\"', '9 \"On Basis\"', 'A \"On Close\"', 'B \"Limit On Close\"', 'C \"Forex Market\"', 'D \"Previously Quoted\"', 'E \"Previously Indicated\"', 'F \"Forex Limit\"', 'G \"Forex Swap\"', 'H \"Forex Previously Quoted\"', 'I \"Funari\"', 'K \"Market To Limit\"', 'P \"Pegged\"']):
            raise ValueError("must be one of enum values ('1 \"Market\"', '2 \"Limit\"', '3 \"Stop\"', '4 \"Stop Limit\"', '5 \"Market on Close\"', '6 \"With or Without\"', '7 \"Limit or Better\"', '8 \"Limit With or Without\"', '9 \"On Basis\"', 'A \"On Close\"', 'B \"Limit On Close\"', 'C \"Forex Market\"', 'D \"Previously Quoted\"', 'E \"Previously Indicated\"', 'F \"Forex Limit\"', 'G \"Forex Swap\"', 'H \"Forex Previously Quoted\"', 'I \"Funari\"', 'K \"Market To Limit\"', 'P \"Pegged\"')")
        return value

    @field_validator('order_status')
    def order_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['-1 \"Invalid Order Status\"', '0 \"New\"', '1 \"Partially Filled\"', '2 \"Filled\"', '3 \"Done for the Day\"', '4 \"Canceled\"', '5 \"Replaced\"', '6 \"Pending Cancel\"', '7 \"Stopped\"', '8 \"Rejected\"', '9 \"Suspended\"', 'A \"Pending New\"', 'B \"Calculated\"', 'C \"Expired\"', 'D \"Restated\"', 'E \"Pending Replace\"']):
            raise ValueError("must be one of enum values ('-1 \"Invalid Order Status\"', '0 \"New\"', '1 \"Partially Filled\"', '2 \"Filled\"', '3 \"Done for the Day\"', '4 \"Canceled\"', '5 \"Replaced\"', '6 \"Pending Cancel\"', '7 \"Stopped\"', '8 \"Rejected\"', '9 \"Suspended\"', 'A \"Pending New\"', 'B \"Calculated\"', 'C \"Expired\"', 'D \"Restated\"', 'E \"Pending Replace\"')")
        return value

    @field_validator('side')
    def side_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['1 \"Buy\"', '2 \"Sell\"', '3 \"Buy Minus\"', '4 \"Sell Plus\"', '5 \"Sell Short\"', '6 \"Sell Short Exempt\"']):
            raise ValueError("must be one of enum values ('1 \"Buy\"', '2 \"Sell\"', '3 \"Buy Minus\"', '4 \"Sell Plus\"', '5 \"Sell Short\"', '6 \"Sell Short Exempt\"')")
        return value

    @field_validator('sec_type')
    def sec_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CS \"Stock\"', 'CASH \"Forex\"', 'CFD \"Contract for Difference\"', 'FUT \"Future\"', 'OPT \"Option\"']):
            raise ValueError("must be one of enum values ('CS \"Stock\"', 'CASH \"Forex\"', 'CFD \"Contract for Difference\"', 'FUT \"Future\"', 'OPT \"Option\"')")
        return value

    @field_validator('tif')
    def tif_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['0 \"Day\"', '1 \"GTC\"', '2 \"At the Opening\"']):
            raise ValueError("must be one of enum values ('0 \"Day\"', '1 \"GTC\"', '2 \"At the Opening\"')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of warnings
        if self.warnings:
            _dict['warnings'] = self.warnings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clientOrderId": obj.get("clientOrderId"),
            "execId": obj.get("execId"),
            "execType": obj.get("execType"),
            "orderType": obj.get("orderType"),
            "orderStatus": obj.get("orderStatus"),
            "symbol": obj.get("symbol"),
            "orderQty": obj.get("orderQty"),
            "price": obj.get("price"),
            "lastShares": obj.get("lastShares"),
            "lastPrice": obj.get("lastPrice"),
            "cumQty": obj.get("cumQty"),
            "leavesQty": obj.get("leavesQty"),
            "avgPrice": obj.get("avgPrice"),
            "side": obj.get("side"),
            "orderId": obj.get("orderId"),
            "account": obj.get("account"),
            "secType": obj.get("secType"),
            "txTime": obj.get("txTime"),
            "rcptTime": obj.get("rcptTime"),
            "tif": obj.get("tif"),
            "conid": obj.get("conid"),
            "currency": obj.get("currency"),
            "exchange": obj.get("exchange"),
            "listingExchange": obj.get("listingExchange"),
            "text": obj.get("text"),
            "warnings": OrderDataWarnings.from_dict(obj["warnings"]) if obj.get("warnings") is not None else None,
            "commCurr": obj.get("commCurr"),
            "comms": obj.get("comms"),
            "realizedPnl": obj.get("realizedPnl")
        })
        return _obj


